# -*- coding: utf-8 -*-
"""
Telegram Ğ±Ğ¾Ñ‚ Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸ Ğ¼Ğ°Ñ€ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ¸ Ñ‚Ğ¾Ğ²Ğ°Ñ€Ğ¾Ğ²
ĞŸÑ€Ğ¾.ĞœĞ°Ñ€ĞºĞ¸Ñ€ÑƒĞ¹ - https://promarkirui.ru
"""

import json
import logging
import os
import re
import hashlib
import sqlite3
from typing import Optional, Dict
from telegram import Update, InlineKeyboardButton, InlineKeyboardMarkup, KeyboardButton, ReplyKeyboardMarkup, ReplyKeyboardRemove
from telegram.ext import (
    Application,
    CommandHandler,
    MessageHandler,
    CallbackQueryHandler,
    ConversationHandler,
    filters,
    ContextTypes
)
from dotenv import load_dotenv

load_dotenv()

logging.basicConfig(
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    level=logging.INFO
)
logger = logging.getLogger(__name__)

DATA_DIR = os.path.join(os.path.dirname(__file__), 'data')
TNVED_MARKING_PATH = os.path.join(DATA_DIR, 'tnved_marking.json')
CATEGORY_REQUIREMENTS_PATH = os.path.join(DATA_DIR, 'category_requirements.json')
TIMELINE_PATH = os.path.join(DATA_DIR, 'marking_timeline.json')
DB_PATH = os.path.join(DATA_DIR, 'promarkirui.db')

tnved_marking: Dict = {}
category_requirements: Dict = {}
marking_timeline: Dict = {}
category_id_map: Dict = {}

# States Ğ´Ğ»Ñ ConversationHandler
WAITING_PHONE, WAITING_CLIENT_TYPE, WAITING_CUSTOM_TYPE = range(3)

# Ğ¢Ğ¸Ğ¿Ñ‹ ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğ¾Ğ²
CLIENT_TYPES = {
    'importer': 'Ğ˜Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€',
    'manufacturer': 'ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒ',
    'retailer': 'Ğ Ğ¾Ğ·Ğ½Ğ¸Ñ‡Ğ½Ñ‹Ğ¹ Ğ¿Ñ€Ğ¾Ğ´Ğ°Ğ²ĞµÑ†',
    'wholesaler': 'ĞĞ¿Ñ‚Ğ¾Ğ²Ğ¸Ğº',
    'marketplace': 'ĞœĞ°Ñ€ĞºĞµÑ‚Ğ¿Ğ»ĞµĞ¹Ñ',
    'accountant': 'Ğ‘ÑƒÑ…Ğ³Ğ°Ğ»Ñ‚ĞµÑ€',
    'consultant': 'ĞšĞ¾Ğ½ÑÑƒĞ»ÑŒÑ‚Ğ°Ğ½Ñ‚/Ğ®Ñ€Ğ¸ÑÑ‚',
    'other': 'Ğ”Ñ€ÑƒĞ³Ğ¾Ğµ'
}

PRODUCT_KEYWORDS = {
    'Ğ¾Ğ±ÑƒĞ²ÑŒ': {'codes': ['6401', '6402', '6403', '6404', '6405'], 'category': 'ĞĞ±ÑƒĞ²ÑŒ'},
    'ĞºÑ€Ğ¾ÑÑĞ¾Ğ²ĞºĞ¸': {'codes': ['6403', '6404'], 'category': 'ĞĞ±ÑƒĞ²ÑŒ'},
    'Ñ‚ÑƒÑ„Ğ»Ğ¸': {'codes': ['6403', '6404'], 'category': 'ĞĞ±ÑƒĞ²ÑŒ'},
    'Ğ±Ğ¾Ñ‚Ğ¸Ğ½ĞºĞ¸': {'codes': ['6403', '6404'], 'category': 'ĞĞ±ÑƒĞ²ÑŒ'},
    'ÑĞ°Ğ¿Ğ¾Ğ³Ğ¸': {'codes': ['6401', '6402', '6403'], 'category': 'ĞĞ±ÑƒĞ²ÑŒ'},

    'Ğ¾Ğ´ĞµĞ¶Ğ´Ğ°': {'codes': ['6201', '6202', '6203', '6204', '6205', '6206'], 'category': 'Ğ›ĞµĞ³ĞºĞ°Ñ Ğ¿Ñ€Ğ¾Ğ¼Ñ‹ÑˆĞ»ĞµĞ½Ğ½Ğ¾ÑÑ‚ÑŒ'},
    'ĞºÑƒÑ€Ñ‚ĞºĞ°': {'codes': ['6201', '6202'], 'category': 'Ğ›ĞµĞ³ĞºĞ°Ñ Ğ¿Ñ€Ğ¾Ğ¼Ñ‹ÑˆĞ»ĞµĞ½Ğ½Ğ¾ÑÑ‚ÑŒ'},
    'Ğ±ĞµĞ»ÑŒĞµ': {'codes': ['6107', '6108'], 'category': 'Ğ›ĞµĞ³ĞºĞ°Ñ Ğ¿Ñ€Ğ¾Ğ¼Ñ‹ÑˆĞ»ĞµĞ½Ğ½Ğ¾ÑÑ‚ÑŒ'},

    'Ğ¼Ğ¾Ğ»Ğ¾ĞºĞ¾': {'codes': ['0401', '0402'], 'category': 'ĞœĞ¾Ğ»Ğ¾Ñ‡Ğ½Ğ°Ñ Ğ¿Ñ€Ğ¾Ğ´ÑƒĞºÑ†Ğ¸Ñ'},
    'Ğ¼Ğ¾Ğ»Ğ¾Ñ‡ĞºĞ°': {'codes': ['0401', '0402', '0403', '0404', '0405', '0406'], 'category': 'ĞœĞ¾Ğ»Ğ¾Ñ‡Ğ½Ğ°Ñ Ğ¿Ñ€Ğ¾Ğ´ÑƒĞºÑ†Ğ¸Ñ'},
    'ÑÑ‹Ñ€': {'codes': ['0406'], 'category': 'ĞœĞ¾Ğ»Ğ¾Ñ‡Ğ½Ğ°Ñ Ğ¿Ñ€Ğ¾Ğ´ÑƒĞºÑ†Ğ¸Ñ'},
    'Ñ‚Ğ²Ğ¾Ñ€Ğ¾Ğ³': {'codes': ['0406'], 'category': 'ĞœĞ¾Ğ»Ğ¾Ñ‡Ğ½Ğ°Ñ Ğ¿Ñ€Ğ¾Ğ´ÑƒĞºÑ†Ğ¸Ñ'},
    'ĞºĞµÑ„Ğ¸Ñ€': {'codes': ['0403'], 'category': 'ĞœĞ¾Ğ»Ğ¾Ñ‡Ğ½Ğ°Ñ Ğ¿Ñ€Ğ¾Ğ´ÑƒĞºÑ†Ğ¸Ñ'},
    'Ğ¹Ğ¾Ğ³ÑƒÑ€Ñ‚': {'codes': ['0403'], 'category': 'ĞœĞ¾Ğ»Ğ¾Ñ‡Ğ½Ğ°Ñ Ğ¿Ñ€Ğ¾Ğ´ÑƒĞºÑ†Ğ¸Ñ'},
    'Ğ¼Ğ¾Ñ€Ğ¾Ğ¶ĞµĞ½Ğ¾Ğµ': {'codes': ['2105'], 'category': 'ĞœĞ¾Ğ»Ğ¾Ñ‡Ğ½Ğ°Ñ Ğ¿Ñ€Ğ¾Ğ´ÑƒĞºÑ†Ğ¸Ñ'},

    'Ğ²Ğ¾Ğ´Ğ°': {'codes': ['2201', '2202'], 'category': 'Ğ£Ğ¿Ğ°ĞºĞ¾Ğ²Ğ°Ğ½Ğ½Ğ°Ñ Ğ²Ğ¾Ğ´Ğ°'},
    'Ğ¼Ğ¸Ğ½ĞµÑ€Ğ°Ğ»ĞºĞ°': {'codes': ['2201'], 'category': 'Ğ£Ğ¿Ğ°ĞºĞ¾Ğ²Ğ°Ğ½Ğ½Ğ°Ñ Ğ²Ğ¾Ğ´Ğ°'},
    'Ğ³Ğ°Ğ·Ğ¸Ñ€Ğ¾Ğ²ĞºĞ°': {'codes': ['2202'], 'category': 'Ğ‘ĞµĞ·Ğ°Ğ»ĞºĞ¾Ğ³Ğ¾Ğ»ÑŒĞ½Ñ‹Ğµ Ğ½Ğ°Ğ¿Ğ¸Ñ‚ĞºĞ¸'},
    'ÑĞ¾Ğº': {'codes': ['2009'], 'category': 'Ğ‘ĞµĞ·Ğ°Ğ»ĞºĞ¾Ğ³Ğ¾Ğ»ÑŒĞ½Ñ‹Ğµ Ğ½Ğ°Ğ¿Ğ¸Ñ‚ĞºĞ¸'},

    'Ğ¿Ğ¸Ğ²Ğ¾': {'codes': ['2203'], 'category': 'ĞŸĞ¸Ğ²Ğ¾ Ğ¸ ÑĞ»Ğ°Ğ±Ğ¾Ğ°Ğ»ĞºĞ¾Ğ³Ğ¾Ğ»ÑŒĞ½Ñ‹Ğµ Ğ½Ğ°Ğ¿Ğ¸Ñ‚ĞºĞ¸'},
    'ÑĞ¸Ğ´Ñ€': {'codes': ['2206'], 'category': 'ĞŸĞ¸Ğ²Ğ¾ Ğ¸ ÑĞ»Ğ°Ğ±Ğ¾Ğ°Ğ»ĞºĞ¾Ğ³Ğ¾Ğ»ÑŒĞ½Ñ‹Ğµ Ğ½Ğ°Ğ¿Ğ¸Ñ‚ĞºĞ¸'},

    'Ñ‚Ğ°Ğ±Ğ°Ğº': {'codes': ['2401', '2402', '2403'], 'category': 'Ğ¢Ğ°Ğ±Ğ°Ñ‡Ğ½Ğ°Ñ Ğ¿Ñ€Ğ¾Ğ´ÑƒĞºÑ†Ğ¸Ñ'},
    'ÑĞ¸Ğ³Ğ°Ñ€ĞµÑ‚Ñ‹': {'codes': ['2402'], 'category': 'Ğ¢Ğ°Ğ±Ğ°Ñ‡Ğ½Ğ°Ñ Ğ¿Ñ€Ğ¾Ğ´ÑƒĞºÑ†Ğ¸Ñ'},
    'Ğ²ĞµĞ¹Ğ¿': {'codes': ['2403'], 'category': 'ĞĞ¸ĞºĞ¾Ñ‚Ğ¸Ğ½Ğ¾ÑĞ¾Ğ´ĞµÑ€Ğ¶Ğ°Ñ‰Ğ°Ñ Ğ¿Ñ€Ğ¾Ğ´ÑƒĞºÑ†Ğ¸Ñ'},

    'Ğ»ĞµĞºĞ°Ñ€ÑÑ‚Ğ²Ğ°': {'codes': ['3001', '3002', '3003', '3004'], 'category': 'Ğ›ĞµĞºĞ°Ñ€ÑÑ‚Ğ²ĞµĞ½Ğ½Ñ‹Ğµ Ğ¿Ñ€ĞµĞ¿Ğ°Ñ€Ğ°Ñ‚Ñ‹'},
    'Ñ‚Ğ°Ğ±Ğ»ĞµÑ‚ĞºĞ¸': {'codes': ['3004'], 'category': 'Ğ›ĞµĞºĞ°Ñ€ÑÑ‚Ğ²ĞµĞ½Ğ½Ñ‹Ğµ Ğ¿Ñ€ĞµĞ¿Ğ°Ñ€Ğ°Ñ‚Ñ‹'},
    'Ğ±Ğ°Ğ´': {'codes': ['2106'], 'category': 'Ğ‘ĞĞ”'},

    'ÑˆĞ¸Ğ½Ñ‹': {'codes': ['4011'], 'category': 'Ğ¨Ğ¸Ğ½Ñ‹ Ğ¸ Ğ¿Ğ¾ĞºÑ€Ñ‹ÑˆĞºĞ¸'},
    'Ğ¿Ğ¾ĞºÑ€Ñ‹ÑˆĞºĞ¸': {'codes': ['4011'], 'category': 'Ğ¨Ğ¸Ğ½Ñ‹ Ğ¸ Ğ¿Ğ¾ĞºÑ€Ñ‹ÑˆĞºĞ¸'},
    'ĞºĞ¾Ğ»ĞµÑĞ°': {'codes': ['4011'], 'category': 'Ğ¨Ğ¸Ğ½Ñ‹ Ğ¸ Ğ¿Ğ¾ĞºÑ€Ñ‹ÑˆĞºĞ¸'},

    'Ğ´ÑƒÑ…Ğ¸': {'codes': ['3303'], 'category': 'ĞŸĞ°Ñ€Ñ„ÑĞ¼ĞµÑ€Ğ¸Ñ'},
    'Ğ¿Ğ°Ñ€Ñ„ÑĞ¼': {'codes': ['3303'], 'category': 'ĞŸĞ°Ñ€Ñ„ÑĞ¼ĞµÑ€Ğ¸Ñ'},

    'Ğ¼ĞµÑ…': {'codes': ['4301', '4302', '4303'], 'category': 'Ğ¢Ğ¾Ğ²Ğ°Ñ€Ñ‹ Ğ¸Ğ· Ğ¼ĞµÑ…Ğ°'},
    'ÑˆÑƒĞ±Ğ°': {'codes': ['4303'], 'category': 'Ğ¢Ğ¾Ğ²Ğ°Ñ€Ñ‹ Ğ¸Ğ· Ğ¼ĞµÑ…Ğ°'},

    'Ğ¾Ñ€Ñ‚ĞµĞ·': {'codes': ['9021'], 'category': 'Ğ¢ĞµÑ…Ğ½Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ ÑÑ€ĞµĞ´ÑÑ‚Ğ²Ğ° Ñ€ĞµĞ°Ğ±Ğ¸Ğ»Ğ¸Ñ‚Ğ°Ñ†Ğ¸Ğ¸'},
    'Ğ¾Ñ€Ñ‚ĞµĞ·Ñ‹': {'codes': ['9021'], 'category': 'Ğ¢ĞµÑ…Ğ½Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ ÑÑ€ĞµĞ´ÑÑ‚Ğ²Ğ° Ñ€ĞµĞ°Ğ±Ğ¸Ğ»Ğ¸Ñ‚Ğ°Ñ†Ğ¸Ğ¸'},
    'Ğ¿Ñ€Ğ¾Ñ‚ĞµĞ·': {'codes': ['9021'], 'category': 'Ğ¢ĞµÑ…Ğ½Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ ÑÑ€ĞµĞ´ÑÑ‚Ğ²Ğ° Ñ€ĞµĞ°Ğ±Ğ¸Ğ»Ğ¸Ñ‚Ğ°Ñ†Ğ¸Ğ¸'},
    'Ğ¿Ñ€Ğ¾Ñ‚ĞµĞ·Ñ‹': {'codes': ['9021'], 'category': 'Ğ¢ĞµÑ…Ğ½Ğ¸Ñ‡ĞµÑĞºĞ¸Ğµ ÑÑ€ĞµĞ´ÑÑ‚Ğ²Ğ° Ñ€ĞµĞ°Ğ±Ğ¸Ğ»Ğ¸Ñ‚Ğ°Ñ†Ğ¸Ğ¸'},
    'ĞºĞ¾Ğ»ÑÑĞºĞ°': {'codes': ['8713'], 'category': 'ĞšÑ€ĞµÑĞ»Ğ°-ĞºĞ¾Ğ»ÑÑĞºĞ¸'},
    'Ğ²ĞµĞ»Ğ¾ÑĞ¸Ğ¿ĞµĞ´': {'codes': ['8711', '8712'], 'category': 'Ğ’ĞµĞ»Ğ¾ÑĞ¸Ğ¿ĞµĞ´Ñ‹'},

    'ĞºĞ¾Ğ½ÑĞµÑ€Ğ²Ñ‹': {'codes': ['1601', '1602', '1604', '1605'], 'category': 'ĞšĞ¾Ğ½ÑĞµÑ€Ğ²Ğ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ°Ñ Ğ¿Ñ€Ğ¾Ğ´ÑƒĞºÑ†Ğ¸Ñ'},
    'Ğ¸ĞºÑ€Ğ°': {'codes': ['1604'], 'category': 'Ğ˜ĞºÑ€Ğ°'},
    'ĞºĞ¾Ñ€Ğ¼': {'codes': ['2309'], 'category': 'ĞšĞ¾Ñ€Ğ¼Ğ° Ğ´Ğ»Ñ Ğ¶Ğ¸Ğ²Ğ¾Ñ‚Ğ½Ñ‹Ñ…'},
}


# ==================== DATABASE ====================

def get_db():
    conn = sqlite3.connect(DB_PATH)
    conn.row_factory = sqlite3.Row
    return conn


def save_lead(telegram_id: int, username: str, first_name: str, last_name: str, phone: str = None, client_type: str = None):
    """Ğ¡Ğ¾Ñ…Ñ€Ğ°Ğ½Ğ¸Ñ‚ÑŒ Ğ¸Ğ»Ğ¸ Ğ¾Ğ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ»Ğ¸Ğ´Ğ° Ğ² Ğ‘Ğ”"""
    try:
        conn = get_db()
        cursor = conn.cursor()

        cursor.execute("SELECT id FROM telegram_leads WHERE telegram_id = ?", (telegram_id,))
        existing = cursor.fetchone()

        if existing:
            if client_type:
                cursor.execute("""
                    UPDATE telegram_leads
                    SET username = ?, first_name = ?, last_name = ?,
                        phone = COALESCE(?, phone),
                        client_type = COALESCE(?, client_type),
                        last_activity = CURRENT_TIMESTAMP,
                        updated_at = CURRENT_TIMESTAMP
                    WHERE telegram_id = ?
                """, (username, first_name, last_name, phone, client_type, telegram_id))
            else:
                cursor.execute("""
                    UPDATE telegram_leads
                    SET username = ?, first_name = ?, last_name = ?,
                        phone = COALESCE(?, phone),
                        last_activity = CURRENT_TIMESTAMP,
                        updated_at = CURRENT_TIMESTAMP
                    WHERE telegram_id = ?
                """, (username, first_name, last_name, phone, telegram_id))
        else:
            cursor.execute("""
                INSERT INTO telegram_leads (telegram_id, username, first_name, last_name, phone, client_type)
                VALUES (?, ?, ?, ?, ?, ?)
            """, (telegram_id, username, first_name, last_name, phone, client_type))

        conn.commit()
        conn.close()
        logger.info(f"Lead saved: {telegram_id} ({first_name}) type={client_type}")
        return True
    except Exception as e:
        logger.error(f"Error saving lead: {e}")
        return False


def update_lead_query(telegram_id: int, query: str, category: str = None):
    """ĞĞ±Ğ½Ğ¾Ğ²Ğ¸Ñ‚ÑŒ Ğ¿Ğ¾ÑĞ»ĞµĞ´Ğ½Ğ¸Ğ¹ Ğ·Ğ°Ğ¿Ñ€Ğ¾Ñ Ğ¸ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ¸ Ğ¸Ğ½Ñ‚ĞµÑ€ĞµÑĞ¾Ğ²"""
    try:
        conn = get_db()
        cursor = conn.cursor()

        cursor.execute("SELECT interested_categories FROM telegram_leads WHERE telegram_id = ?", (telegram_id,))
        row = cursor.fetchone()

        if row:
            categories = []
            if row['interested_categories']:
                try:
                    categories = json.loads(row['interested_categories'])
                except:
                    categories = []

            if category and category not in categories:
                categories.append(category)

            cursor.execute("""
                UPDATE telegram_leads
                SET last_query = ?,
                    interested_categories = ?,
                    queries_count = queries_count + 1,
                    last_activity = CURRENT_TIMESTAMP
                WHERE telegram_id = ?
            """, (query, json.dumps(categories, ensure_ascii=False), telegram_id))

            conn.commit()
        conn.close()
    except Exception as e:
        logger.error(f"Error updating lead query: {e}")


def check_lead_has_phone(telegram_id: int) -> bool:
    try:
        conn = get_db()
        cursor = conn.cursor()
        cursor.execute("SELECT phone FROM telegram_leads WHERE telegram_id = ?", (telegram_id,))
        row = cursor.fetchone()
        conn.close()
        return row and row['phone'] and len(row['phone']) > 5
    except:
        return False


def check_lead_has_type(telegram_id: int) -> bool:
    try:
        conn = get_db()
        cursor = conn.cursor()
        cursor.execute("SELECT client_type FROM telegram_leads WHERE telegram_id = ?", (telegram_id,))
        row = cursor.fetchone()
        conn.close()
        return row and row['client_type'] and len(row['client_type']) > 0
    except:
        return False


# ==================== DATA LOADING ====================

def get_category_id(category: str) -> str:
    short_id = hashlib.md5(category.encode()).hexdigest()[:8]
    category_id_map[short_id] = category
    return short_id


def get_category_by_id(cat_id: str) -> Optional[str]:
    return category_id_map.get(cat_id)


def load_data():
    global tnved_marking, category_requirements, marking_timeline

    try:
        with open(TNVED_MARKING_PATH, 'r', encoding='utf-8') as f:
            tnved_marking = json.load(f)
        logger.info(f"Ğ—Ğ°Ğ³Ñ€ÑƒĞ¶ĞµĞ½Ğ¾ {len(tnved_marking)} ĞºĞ¾Ğ´Ğ¾Ğ² Ğ¢ĞĞ’Ğ­Ğ”")
    except Exception as e:
        logger.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ¸ tnved_marking.json: {e}")

    try:
        with open(CATEGORY_REQUIREMENTS_PATH, 'r', encoding='utf-8') as f:
            category_requirements = json.load(f)
        for cat_name in category_requirements.keys():
            get_category_id(cat_name)
    except Exception as e:
        logger.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ¸ category_requirements.json: {e}")

    try:
        with open(TIMELINE_PATH, 'r', encoding='utf-8') as f:
            marking_timeline = json.load(f)
        for cat_name in marking_timeline.get('categories', {}).keys():
            get_category_id(cat_name)
    except Exception as e:
        logger.error(f"ĞÑˆĞ¸Ğ±ĞºĞ° Ğ·Ğ°Ğ³Ñ€ÑƒĞ·ĞºĞ¸ marking_timeline.json: {e}")


# ==================== SEARCH FUNCTIONS ====================

def normalize_code(code: str) -> str:
    return re.sub(r'\s+', '', code.strip())


def find_by_keyword(text: str) -> Optional[Dict]:
    text_lower = text.lower().strip()

    if text_lower in PRODUCT_KEYWORDS:
        return PRODUCT_KEYWORDS[text_lower]

    for keyword, data in PRODUCT_KEYWORDS.items():
        if keyword in text_lower or text_lower in keyword:
            return data

    results = []
    for code, entries in tnved_marking.items():
        for entry in entries:
            product = entry.get('product', '').lower()
            subcategory = entry.get('subcategory', '').lower()
            if text_lower in product or text_lower in subcategory:
                results.append({'code': code, 'entry': entry})
                if len(results) >= 5:
                    break
        if len(results) >= 5:
            break

    if results:
        return {
            'search_results': results,
            'category': results[0]['entry'].get('subcategory', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°')
        }
    return None


def find_marking_info(code: str) -> Optional[Dict]:
    code = normalize_code(code)

    if code in tnved_marking:
        return {'code': code, 'entries': tnved_marking[code], 'match_type': 'exact'}

    for length in range(len(code) - 1, 3, -1):
        prefix = code[:length]
        if prefix in tnved_marking:
            return {'code': code, 'matched_prefix': prefix, 'entries': tnved_marking[prefix], 'match_type': 'prefix'}

    return None


def get_category_details(subcategory: str) -> Optional[Dict]:
    subcategory_lower = subcategory.lower().strip()

    for cat_name, cat_data in category_requirements.items():
        if cat_name.lower() == subcategory_lower:
            return {'category': cat_name, 'data': cat_data}

    for cat_name, cat_data in category_requirements.items():
        if subcategory_lower in cat_name.lower() or cat_name.lower() in subcategory_lower:
            return {'category': cat_name, 'data': cat_data}

    return None


def get_timeline_for_category(category: str) -> Optional[Dict]:
    category_lower = category.lower().strip()
    categories = marking_timeline.get('categories', {})

    for cat_name, cat_data in categories.items():
        if cat_name.lower() == category_lower:
            return {'category': cat_name, 'data': cat_data}

    for cat_name, cat_data in categories.items():
        if category_lower in cat_name.lower() or cat_name.lower() in category_lower:
            return {'category': cat_name, 'data': cat_data}

    return None


# ==================== FORMATTERS ====================

def format_timeline(category: str) -> str:
    timeline_data = get_timeline_for_category(category)

    if not timeline_data:
        return f"Ğ¡Ñ€Ğ¾ĞºĞ¸ Ğ´Ğ»Ñ Â«{category}Â» Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ñ‹."

    cat_name = timeline_data['category']
    data = timeline_data['data']
    events = data.get('events', [])
    status = data.get('status_label', '')

    text = "ğŸ“… Ğ¡Ğ ĞĞšĞ˜ ĞœĞĞ ĞšĞ˜Ğ ĞĞ’ĞšĞ˜\n"
    text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
    text += f"ğŸ“¦ ĞšĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ñ: {cat_name}\n"
    text += f"ğŸ“Š Ğ¡Ñ‚Ğ°Ñ‚ÑƒÑ: {status}\n\n"

    key_events = {'registration': [], 'mandatory_start': [], 'retail': [], 'ban': [], 'retail_permission': []}

    for event in events:
        event_type = event.get('type', '')
        if event_type in key_events:
            key_events[event_type].append(event)

    shown = set()

    if key_events['registration']:
        e = key_events['registration'][0]
        audiences = ', '.join(e.get('audiences_display', []))
        text += f"ğŸ“ Ğ ĞµĞ³Ğ¸ÑÑ‚Ñ€Ğ°Ñ†Ğ¸Ñ:\n   {e['date_display']} â€” {audiences}\n\n"
        shown.add(e['date'])

    if key_events['mandatory_start']:
        text += "ğŸš€ Ğ¡Ñ‚Ğ°Ñ€Ñ‚ Ğ¼Ğ°Ñ€ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ¸:\n"
        for e in key_events['mandatory_start'][:3]:
            if e['date'] not in shown:
                title_short = e['title'].replace('Ğ¡Ñ‚Ğ°Ñ€Ñ‚ Ğ¼Ğ°Ñ€ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ¸ ', '').replace('Ğ¡Ñ‚Ğ°Ñ€Ñ‚ Ğ¾Ğ±ÑĞ·Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾Ğ¹ Ğ¼Ğ°Ñ€ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞ¸ ', '')[:50]
                text += f"   â€¢ {e['date_display']} â€” {title_short}\n"
                shown.add(e['date'])
        text += "\n"

    if key_events['ban']:
        e = key_events['ban'][0]
        text += f"â›” Ğ—Ğ°Ğ¿Ñ€ĞµÑ‚ Ğ½ĞµĞ¼Ğ°Ñ€ĞºĞ¸Ñ€Ğ¾Ğ²Ğ°Ğ½Ğ½Ğ¾Ğ³Ğ¾:\n   {e['date_display']}\n\n"

    text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
    text += "ğŸŒ promarkirui.ru/timeline"
    return text


def format_marking_result(info: Dict) -> str:
    entry = info['entries'][0]
    code = info['code']
    group = entry.get('group', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°')
    subcategory = entry.get('subcategory', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½Ğ°')
    product = entry.get('product', 'ĞĞµ ÑƒĞºĞ°Ğ·Ğ°Ğ½')

    result = "âœ… Ğ¢ĞĞ’ĞĞ  ĞŸĞĞ”Ğ›Ğ•Ğ–Ğ˜Ğ¢ ĞœĞĞ ĞšĞ˜Ğ ĞĞ’ĞšĞ•\n"
    result += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
    result += f"ğŸ”¢ ĞšĞ¾Ğ´ Ğ¢ĞĞ’Ğ­Ğ”: {code}\n"

    if info.get('match_type') == 'prefix':
        result += f"   (Ğ½Ğ°Ğ¹Ğ´ĞµĞ½ Ğ¿Ğ¾: {info['matched_prefix']})\n"

    result += f"\nğŸ“ Ğ“Ñ€ÑƒĞ¿Ğ¿Ğ°: {group}\n"
    result += f"ğŸ“¦ ĞšĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ñ: {subcategory}\n"
    product_short = product[:100] + '...' if len(product) > 100 else product
    result += f"ğŸ· Ğ¢Ğ¾Ğ²Ğ°Ñ€: {product_short}\n"

    details = get_category_details(subcategory)
    if details:
        decree = details['data'].get('decree', {})
        result += f"\nğŸ“‹ ĞŸĞŸ Ğ Ğ¤ â„– {decree.get('number', '?')} Ğ¾Ñ‚ {decree.get('date', '?')}\n"

    result += "\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
    result += "ğŸŒ promarkirui.ru"
    return result


def format_keyword_result(keyword_data: Dict, search_text: str) -> str:
    if 'codes' in keyword_data:
        codes = keyword_data['codes']
        category = keyword_data['category']

        result = "âœ… Ğ¢ĞĞ’ĞĞ  ĞŸĞĞ”Ğ›Ğ•Ğ–Ğ˜Ğ¢ ĞœĞĞ ĞšĞ˜Ğ ĞĞ’ĞšĞ•\n"
        result += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        result += f"ğŸ” Ğ—Ğ°Ğ¿Ñ€Ğ¾Ñ: {search_text}\n"
        result += f"ğŸ“¦ ĞšĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ñ: {category}\n\n"
        result += "ğŸ”¢ ĞšĞ¾Ğ´Ñ‹ Ğ¢ĞĞ’Ğ­Ğ”:\n"

        for code in codes[:4]:
            if code in tnved_marking:
                entry = tnved_marking[code][0]
                product_name = entry.get('product', '')[:30]
                result += f"   â€¢ {code} â€” {product_name}\n"
            else:
                result += f"   â€¢ {code}\n"

        details = get_category_details(category)
        if details:
            decree = details['data'].get('decree', {})
            result += f"\nğŸ“‹ ĞŸĞŸ Ğ Ğ¤ â„– {decree.get('number', '?')} Ğ¾Ñ‚ {decree.get('date', '?')}\n"

        result += "\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        result += "ğŸŒ promarkirui.ru"
        return result

    if 'search_results' in keyword_data:
        results = keyword_data['search_results']
        result = f"ğŸ” ĞĞĞ™Ğ”Ğ•ĞĞ« Ğ¢ĞĞ’ĞĞ Ğ«\n"
        result += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        result += f"Ğ—Ğ°Ğ¿Ñ€Ğ¾Ñ: {search_text}\n\n"

        for item in results[:4]:
            code = item['code']
            entry = item['entry']
            product = entry.get('product', '')[:30]
            result += f"   â€¢ {code} â€” {product}\n"

        result += "\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        result += "ğŸŒ promarkirui.ru"
        return result

    return None


def format_not_found(text: str) -> str:
    return (
        f"âŒ Â«{text}Â» â€” Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ¾\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        f"Ğ’Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ñ‹Ğµ Ğ¿Ñ€Ğ¸Ñ‡Ğ¸Ğ½Ñ‹:\n"
        f"â€¢ Ğ¢Ğ¾Ğ²Ğ°Ñ€ Ğ½Ğµ Ğ¿Ğ¾Ğ´Ğ»ĞµĞ¶Ğ¸Ñ‚ Ğ¼Ğ°Ñ€ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞµ\n"
        f"â€¢ ĞŸĞ¾Ğ¿Ñ€Ğ¾Ğ±ÑƒĞ¹Ñ‚Ğµ Ğ´Ñ€ÑƒĞ³Ğ¾Ğµ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ\n\n"
        f"ğŸ’¡ ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹: Ğ¾Ğ±ÑƒĞ²ÑŒ, Ğ¼Ğ¾Ğ»Ğ¾ĞºĞ¾, Ğ¿Ğ¸Ğ²Ğ¾, 6403\n\n"
        f"â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
        f"ğŸ“ ĞÑƒĞ¶Ğ½Ğ° Ğ¿Ğ¾Ğ¼Ğ¾Ñ‰ÑŒ? promarkirui.ru/consultation"
    )


# ==================== MENU BUILDERS ====================

def create_main_menu():
    """Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ Ğ±Ğ¾Ñ‚Ğ° - ĞºÑ€Ğ°ÑĞ¸Ğ²Ğ¾Ğµ Ğ¸ Ñ„ÑƒĞ½ĞºÑ†Ğ¸Ğ¾Ğ½Ğ°Ğ»ÑŒĞ½Ğ¾Ğµ"""
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("ğŸ” ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ Ñ‚Ğ¾Ğ²Ğ°Ñ€", callback_data="new_search")],
        [InlineKeyboardButton("ğŸ“š Ğ’ÑĞµ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ¸", callback_data="cat")],
        [
            InlineKeyboardButton("ğŸ¤– AI-ĞºĞ¾Ğ½ÑÑƒĞ»ÑŒÑ‚Ğ°Ğ½Ñ‚", callback_data="ai_consultant"),
            InlineKeyboardButton("ğŸ“ ĞšĞ¾Ğ½ÑÑƒĞ»ÑŒÑ‚Ğ°Ñ†Ğ¸Ñ", url="https://promarkirui.ru/consultation")
        ],
        [
            InlineKeyboardButton("ğŸ“ ĞĞ±ÑƒÑ‡ĞµĞ½Ğ¸Ğµ", url="https://promarkirui.ru/training"),
            InlineKeyboardButton("ğŸ¤ ĞŸĞ°Ñ€Ñ‚Ğ½Ñ‘Ñ€Ğ°Ğ¼", url="https://promarkirui.ru/partners")
        ],
        [InlineKeyboardButton("ğŸŒ promarkirui.ru", url="https://promarkirui.ru")]
    ])


def create_result_buttons(category: str):
    """ĞšĞ½Ğ¾Ğ¿ĞºĞ¸ Ğ¿Ğ¾ÑĞ»Ğµ Ñ€ĞµĞ·ÑƒĞ»ÑŒÑ‚Ğ°Ñ‚Ğ° Ğ¿Ğ¾Ğ¸ÑĞºĞ°"""
    cat_id = get_category_id(category)
    return InlineKeyboardMarkup([
        [
            InlineKeyboardButton("ğŸ“… Ğ¡Ñ€Ğ¾ĞºĞ¸", callback_data=f"t:{cat_id}"),
            InlineKeyboardButton("âš ï¸ Ğ˜ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ", callback_data=f"e:{cat_id}")
        ],
        [
            InlineKeyboardButton("ğŸ” ĞĞ¾Ğ²Ñ‹Ğ¹ Ğ¿Ğ¾Ğ¸ÑĞº", callback_data="new_search"),
            InlineKeyboardButton("ğŸ“š ĞšĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ¸", callback_data="cat")
        ],
        [InlineKeyboardButton("ğŸ“ ĞšĞ¾Ğ½ÑÑƒĞ»ÑŒÑ‚Ğ°Ñ†Ğ¸Ñ", url="https://promarkirui.ru/consultation")],
        [InlineKeyboardButton("ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="main_menu")]
    ])


def create_back_menu():
    """ĞšĞ½Ğ¾Ğ¿ĞºĞ¸ Ğ½Ğ°Ğ²Ğ¸Ğ³Ğ°Ñ†Ğ¸Ğ¸ Ğ½Ğ°Ğ·Ğ°Ğ´"""
    return InlineKeyboardMarkup([
        [
            InlineKeyboardButton("ğŸ” ĞĞ¾Ğ²Ñ‹Ğ¹ Ğ¿Ğ¾Ğ¸ÑĞº", callback_data="new_search"),
            InlineKeyboardButton("ğŸ“š ĞšĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ¸", callback_data="cat")
        ],
        [InlineKeyboardButton("ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="main_menu")]
    ])


def create_search_menu():
    """ĞœĞµĞ½Ñ Ğ²Ğ¾ Ğ²Ñ€ĞµĞ¼Ñ Ğ¿Ğ¾Ğ¸ÑĞºĞ°"""
    return InlineKeyboardMarkup([
        [InlineKeyboardButton("ğŸ“š Ğ’ÑĞµ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ¸", callback_data="cat")],
        [InlineKeyboardButton("ğŸ  Ğ“Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ", callback_data="main_menu")]
    ])


# ==================== HANDLERS ====================

async def start(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚Ñ‡Ğ¸Ğº /start"""
    user = update.effective_user
    telegram_id = user.id
    username = user.username
    first_name = user.first_name or ""
    last_name = user.last_name or ""

    save_lead(telegram_id, username, first_name, last_name)

    has_phone = check_lead_has_phone(telegram_id)
    has_type = check_lead_has_type(telegram_id)

    if has_phone and has_type:
        welcome_text = (
            f"ğŸ‘‹ Ğ¡ Ğ²Ğ¾Ğ·Ğ²Ñ€Ğ°Ñ‰ĞµĞ½Ğ¸ĞµĞ¼, {first_name}!\n"
            "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
            "Ğ¯ Ğ¿Ğ¾Ğ¼Ğ¾Ğ³Ñƒ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ, Ğ¿Ğ¾Ğ´Ğ»ĞµĞ¶Ğ¸Ñ‚ Ğ»Ğ¸\n"
            "Ğ²Ğ°Ñˆ Ñ‚Ğ¾Ğ²Ğ°Ñ€ Ğ¾Ğ±ÑĞ·Ğ°Ñ‚ĞµĞ»ÑŒĞ½Ğ¾Ğ¹ Ğ¼Ğ°Ñ€ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞµ.\n\n"
            "ğŸ’¡ ĞĞ°Ğ¿Ğ¸ÑˆĞ¸Ñ‚Ğµ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ‚Ğ¾Ğ²Ğ°Ñ€Ğ°\n"
            "   Ğ¸Ğ»Ğ¸ ĞºĞ¾Ğ´ Ğ¢ĞĞ’Ğ­Ğ”\n\n"
            "ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹: Ğ¾Ğ±ÑƒĞ²ÑŒ, Ğ¼Ğ¾Ğ»Ğ¾ĞºĞ¾, 6403\n"
            "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        )
        await update.message.reply_text(welcome_text, reply_markup=create_main_menu())
        return ConversationHandler.END

    if has_phone and not has_type:
        return await ask_client_type(update, context)

    keyboard = ReplyKeyboardMarkup(
        [[KeyboardButton("ğŸ“± ĞŸĞ¾Ğ´ĞµĞ»Ğ¸Ñ‚ÑŒÑÑ Ğ½Ğ¾Ğ¼ĞµÑ€Ğ¾Ğ¼", request_contact=True)]],
        resize_keyboard=True,
        one_time_keyboard=True
    )

    welcome_text = (
        f"ğŸ‘‹ ĞŸÑ€Ğ¸Ğ²ĞµÑ‚, {first_name}!\n"
        "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        "Ğ¯ â€” Ğ±Ğ¾Ñ‚ ÑĞµÑ€Ğ²Ğ¸ÑĞ° ĞŸÑ€Ğ¾.ĞœĞ°Ñ€ĞºĞ¸Ñ€ÑƒĞ¹\n"
        "ĞŸĞ¾Ğ¼Ğ¾Ğ³Ñƒ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ Ğ¼Ğ°Ñ€ĞºĞ¸Ñ€Ğ¾Ğ²ĞºÑƒ Ñ‚Ğ¾Ğ²Ğ°Ñ€Ğ¾Ğ².\n\n"
        "ğŸ“± ĞŸĞ¾Ğ´ĞµĞ»Ğ¸Ñ‚ĞµÑÑŒ Ğ½Ğ¾Ğ¼ĞµÑ€Ğ¾Ğ¼ Ñ‚ĞµĞ»ĞµÑ„Ğ¾Ğ½Ğ°:\n"
        "â€¢ Ğ£Ğ²ĞµĞ´Ğ¾Ğ¼Ğ»ĞµĞ½Ğ¸Ñ Ğ¾Ğ± Ğ¸Ğ·Ğ¼ĞµĞ½ĞµĞ½Ğ¸ÑÑ… ÑÑ€Ğ¾ĞºĞ¾Ğ²\n"
        "â€¢ Ğ’Ğ¾Ğ·Ğ¼Ğ¾Ğ¶Ğ½Ğ¾ÑÑ‚ÑŒ ĞºĞ¾Ğ½ÑÑƒĞ»ÑŒÑ‚Ğ°Ñ†Ğ¸Ğ¸\n\n"
        "ğŸ‘‡ ĞĞ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ ĞºĞ½Ğ¾Ğ¿ĞºÑƒ Ğ½Ğ¸Ğ¶Ğµ"
    )

    await update.message.reply_text(welcome_text, reply_markup=keyboard)

    return WAITING_PHONE


async def ask_client_type(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ğ¡Ğ¿Ñ€Ğ¾ÑĞ¸Ñ‚ÑŒ Ñ‚Ğ¸Ğ¿ ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğ°"""
    keyboard = InlineKeyboardMarkup([
        [
            InlineKeyboardButton("ğŸ“¦ Ğ˜Ğ¼Ğ¿Ğ¾Ñ€Ñ‚Ñ‘Ñ€", callback_data="type:importer"),
            InlineKeyboardButton("ğŸ­ ĞŸÑ€Ğ¾Ğ¸Ğ·Ğ²Ğ¾Ğ´Ğ¸Ñ‚ĞµĞ»ÑŒ", callback_data="type:manufacturer")
        ],
        [
            InlineKeyboardButton("ğŸª Ğ Ğ¾Ğ·Ğ½Ğ¸Ñ†Ğ°", callback_data="type:retailer"),
            InlineKeyboardButton("ğŸ“Š ĞĞ¿Ñ‚Ğ¾Ğ²Ğ¸Ğº", callback_data="type:wholesaler")
        ],
        [
            InlineKeyboardButton("ğŸ›’ ĞœĞ°Ñ€ĞºĞµÑ‚Ğ¿Ğ»ĞµĞ¹Ñ", callback_data="type:marketplace"),
            InlineKeyboardButton("ğŸ“‹ Ğ‘ÑƒÑ…Ğ³Ğ°Ğ»Ñ‚ĞµÑ€", callback_data="type:accountant")
        ],
        [InlineKeyboardButton("âš–ï¸ ĞšĞ¾Ğ½ÑÑƒĞ»ÑŒÑ‚Ğ°Ğ½Ñ‚ / Ğ®Ñ€Ğ¸ÑÑ‚", callback_data="type:consultant")],
        [InlineKeyboardButton("âœï¸ Ğ”Ñ€ÑƒĞ³Ğ¾Ğµ (Ğ²Ğ²ĞµÑÑ‚Ğ¸)", callback_data="type:custom")]
    ])

    text = (
        "ğŸ‘¤ ĞšÑ‚Ğ¾ Ğ²Ñ‹?\n"
        "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ñ‚Ğ¸Ğ¿ Ğ´ĞµÑÑ‚ĞµĞ»ÑŒĞ½Ğ¾ÑÑ‚Ğ¸:\n"
        "Ğ­Ñ‚Ğ¾ Ğ¿Ğ¾Ğ¼Ğ¾Ğ¶ĞµÑ‚ Ğ¿Ğ¾Ğ´Ğ¾Ğ±Ñ€Ğ°Ñ‚ÑŒ\n"
        "Ñ€ĞµĞ»ĞµĞ²Ğ°Ğ½Ñ‚Ğ½ÑƒÑ Ğ¸Ğ½Ñ„Ğ¾Ñ€Ğ¼Ğ°Ñ†Ğ¸Ñ"
    )

    if update.callback_query:
        await update.callback_query.edit_message_text(text, reply_markup=keyboard)
    else:
        await update.message.reply_text(text, reply_markup=keyboard)

    return WAITING_CLIENT_TYPE


async def receive_contact(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ĞºĞ¾Ğ½Ñ‚Ğ°ĞºÑ‚Ğ°"""
    user = update.effective_user
    contact = update.message.contact

    if contact:
        phone = contact.phone_number
        save_lead(user.id, user.username, user.first_name, user.last_name, phone)

        await update.message.reply_text(
            "âœ… Ğ¡Ğ¿Ğ°ÑĞ¸Ğ±Ğ¾! ĞĞ¾Ğ¼ĞµÑ€ ÑĞ¾Ñ…Ñ€Ğ°Ğ½Ñ‘Ğ½.",
            reply_markup=ReplyKeyboardRemove()
        )

        return await ask_client_type(update, context)

    return WAITING_PHONE


async def handle_phone_text(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """Ğ•ÑĞ»Ğ¸ Ğ¿Ğ¾Ğ»ÑŒĞ·Ğ¾Ğ²Ğ°Ñ‚ĞµĞ»ÑŒ Ğ¿Ğ¸ÑˆĞµÑ‚ Ñ‚ĞµĞºÑÑ‚ Ğ²Ğ¼ĞµÑÑ‚Ğ¾ Ğ½Ğ°Ğ¶Ğ°Ñ‚Ğ¸Ñ ĞºĞ½Ğ¾Ğ¿ĞºĞ¸"""
    text = update.message.text.strip()

    phone_pattern = re.match(r'^[\+]?[0-9\s\-\(\)]{10,}$', text)

    if phone_pattern:
        user = update.effective_user
        save_lead(user.id, user.username, user.first_name, user.last_name, text)

        await update.message.reply_text(
            "âœ… Ğ¡Ğ¿Ğ°ÑĞ¸Ğ±Ğ¾! ĞĞ¾Ğ¼ĞµÑ€ ÑĞ¾Ñ…Ñ€Ğ°Ğ½Ñ‘Ğ½.",
            reply_markup=ReplyKeyboardRemove()
        )
        return await ask_client_type(update, context)

    keyboard = ReplyKeyboardMarkup(
        [[KeyboardButton("ğŸ“± ĞŸĞ¾Ğ´ĞµĞ»Ğ¸Ñ‚ÑŒÑÑ Ğ½Ğ¾Ğ¼ĞµÑ€Ğ¾Ğ¼", request_contact=True)]],
        resize_keyboard=True,
        one_time_keyboard=True
    )

    await update.message.reply_text(
        "âš ï¸ ĞĞ°Ğ¶Ğ¼Ğ¸Ñ‚Ğµ ĞºĞ½Ğ¾Ğ¿ĞºÑƒ Â«ĞŸĞ¾Ğ´ĞµĞ»Ğ¸Ñ‚ÑŒÑÑ Ğ½Ğ¾Ğ¼ĞµÑ€Ğ¾Ğ¼Â»\nĞ¸Ğ»Ğ¸ Ğ²Ğ²ĞµĞ´Ğ¸Ñ‚Ğµ Ğ½Ğ¾Ğ¼ĞµÑ€: +79991234567",
        reply_markup=keyboard
    )

    return WAITING_PHONE


async def receive_client_type(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ Ñ‚Ğ¸Ğ¿Ğ° ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğ°"""
    query = update.callback_query
    await query.answer()

    data = query.data

    if data == "type:custom":
        await query.edit_message_text(
            "âœï¸ ĞĞ°Ğ¿Ğ¸ÑˆĞ¸Ñ‚Ğµ ĞºÑ‚Ğ¾ Ğ²Ñ‹:\n"
            "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
            "ĞĞ°Ğ¿Ñ€Ğ¸Ğ¼ĞµÑ€: Ğ»Ğ¾Ğ³Ğ¸ÑÑ‚, Ñ‚Ğ°Ğ¼Ğ¾Ğ¶ĞµĞ½Ğ½Ñ‹Ğ¹\n"
            "Ğ±Ñ€Ğ¾ĞºĞµÑ€, ÑĞºĞ»Ğ°Ğ´, ĞºÑƒÑ€ÑŒĞµÑ€..."
        )
        return WAITING_CUSTOM_TYPE

    if data.startswith("type:"):
        client_type = data[5:]
        user = query.from_user

        save_lead(user.id, user.username, user.first_name, user.last_name, client_type=client_type)

        type_label = CLIENT_TYPES.get(client_type, client_type)

        success_text = (
            f"âœ… ĞÑ‚Ğ»Ğ¸Ñ‡Ğ½Ğ¾! Ğ’Ñ‹: {type_label}\n"
            "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
            "Ğ¢ĞµĞ¿ĞµÑ€ÑŒ Ğ²Ñ‹ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ:\n\n"
            "ğŸ” ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ Ñ‚Ğ¾Ğ²Ğ°Ñ€ â€” Ğ½Ğ°Ğ¿Ğ¸ÑˆĞ¸Ñ‚Ğµ\n"
            "   Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¸Ğ»Ğ¸ ĞºĞ¾Ğ´ Ğ¢ĞĞ’Ğ­Ğ”\n\n"
            "ğŸ’¡ ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹: Ğ¾Ğ±ÑƒĞ²ÑŒ, Ğ¼Ğ¾Ğ»Ğ¾ĞºĞ¾, 6403\n"
            "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        )

        await query.edit_message_text(success_text, reply_markup=create_main_menu())

        return ConversationHandler.END

    return WAITING_CLIENT_TYPE


async def receive_custom_type(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ĞŸĞ¾Ğ»ÑƒÑ‡ĞµĞ½Ğ¸Ğµ ĞºĞ°ÑÑ‚Ğ¾Ğ¼Ğ½Ğ¾Ğ³Ğ¾ Ñ‚Ğ¸Ğ¿Ğ° ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğ°"""
    text = update.message.text.strip()
    user = update.effective_user

    save_lead(user.id, user.username, user.first_name, user.last_name, client_type=text)

    success_text = (
        f"âœ… ĞÑ‚Ğ»Ğ¸Ñ‡Ğ½Ğ¾! Ğ’Ñ‹: {text}\n"
        "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        "Ğ¢ĞµĞ¿ĞµÑ€ÑŒ Ğ²Ñ‹ Ğ¼Ğ¾Ğ¶ĞµÑ‚Ğµ:\n\n"
        "ğŸ” ĞŸÑ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ Ñ‚Ğ¾Ğ²Ğ°Ñ€ â€” Ğ½Ğ°Ğ¿Ğ¸ÑˆĞ¸Ñ‚Ğµ\n"
        "   Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¸Ğ»Ğ¸ ĞºĞ¾Ğ´ Ğ¢ĞĞ’Ğ­Ğ”\n\n"
        "ğŸ’¡ ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹: Ğ¾Ğ±ÑƒĞ²ÑŒ, Ğ¼Ğ¾Ğ»Ğ¾ĞºĞ¾, 6403\n"
        "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    )

    await update.message.reply_text(success_text, reply_markup=create_main_menu())

    return ConversationHandler.END


async def help_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    help_text = (
        "â“ Ğ¡ĞŸĞ ĞĞ’ĞšĞ\n"
        "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        "ğŸ” ĞšĞ°Ğº Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€Ğ¸Ñ‚ÑŒ Ñ‚Ğ¾Ğ²Ğ°Ñ€:\n"
        "   ĞĞ°Ğ¿Ğ¸ÑˆĞ¸Ñ‚Ğµ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ğ¸Ğ»Ğ¸ ĞºĞ¾Ğ´ Ğ¢ĞĞ’Ğ­Ğ”\n\n"
        "ğŸ’¡ ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹ Ğ·Ğ°Ğ¿Ñ€Ğ¾ÑĞ¾Ğ²:\n"
        "   â€¢ Ğ¾Ğ±ÑƒĞ²ÑŒ, Ğ¼Ğ¾Ğ»Ğ¾ĞºĞ¾, ÑˆĞ¸Ğ½Ñ‹\n"
        "   â€¢ Ğ¿Ğ¸Ğ²Ğ¾, Ğ¾Ñ€Ñ‚ĞµĞ·Ñ‹, Ğ´ÑƒÑ…Ğ¸\n"
        "   â€¢ 6403, 0401, 4011\n\n"
        "ğŸ“š ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ñ‹:\n"
        "   /menu â€” Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ\n"
        "   /categories â€” Ğ²ÑĞµ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ¸\n"
        "   /help â€” ÑÑ‚Ğ° ÑĞ¿Ñ€Ğ°Ğ²ĞºĞ°\n"
        "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    )
    await update.message.reply_text(help_text, reply_markup=create_main_menu())


async def menu_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ĞšĞ¾Ğ¼Ğ°Ğ½Ğ´Ğ° /menu - Ğ¿Ğ¾ĞºĞ°Ğ·Ğ°Ñ‚ÑŒ Ğ³Ğ»Ğ°Ğ²Ğ½Ğ¾Ğµ Ğ¼ĞµĞ½Ñ"""
    menu_text = (
        "ğŸ  Ğ“Ğ›ĞĞ’ĞĞĞ• ĞœĞ•ĞĞ®\n"
        "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ Ğ¸Ğ»Ğ¸ Ğ½Ğ°Ğ¿Ğ¸ÑˆĞ¸Ñ‚Ğµ\n"
        "Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ‚Ğ¾Ğ²Ğ°Ñ€Ğ° Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸\n"
        "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    )
    await update.message.reply_text(menu_text, reply_markup=create_main_menu())


async def categories_command(update: Update, context: ContextTypes.DEFAULT_TYPE):
    text = "ğŸ“š ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ˜ ĞœĞĞ ĞšĞ˜Ğ ĞĞ’ĞšĞ˜\n"
    text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
    for i, (cat_name, cat_data) in enumerate(category_requirements.items(), 1):
        decree = cat_data.get('decree', {})
        text += f"{i}. {cat_name}\n   ğŸ“‹ ĞŸĞŸ Ğ Ğ¤ â„– {decree.get('number', '?')}\n\n"
    text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
    await update.message.reply_text(text, reply_markup=create_back_menu())


async def handle_message(update: Update, context: ContextTypes.DEFAULT_TYPE):
    """ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ñ‚ĞµĞºÑÑ‚Ğ¾Ğ²Ñ‹Ñ… ÑĞ¾Ğ¾Ğ±Ñ‰ĞµĞ½Ğ¸Ğ¹"""
    text = update.message.text.strip()
    user = update.effective_user

    code = normalize_code(text)
    if re.match(r'^\d{4,10}$', code):
        await process_code(update, code)
        return

    keyword_data = find_by_keyword(text)

    if keyword_data:
        category = keyword_data.get('category', '')
        update_lead_query(user.id, text, category)

        result = format_keyword_result(keyword_data, text)

        if category:
            buttons = create_result_buttons(category)
        else:
            buttons = create_back_menu()

        await update.message.reply_text(result, reply_markup=buttons)
    else:
        await update.message.reply_text(
            format_not_found(text),
            reply_markup=create_back_menu()
        )


async def process_code(update: Update, code: str):
    user = update.effective_user
    code = normalize_code(code)
    info = find_marking_info(code)

    if info:
        category = info['entries'][0].get('subcategory', '')
        update_lead_query(user.id, code, category)

        result = format_marking_result(info)
        buttons = create_result_buttons(category)
        await update.message.reply_text(result, reply_markup=buttons)
    else:
        await update.message.reply_text(
            format_not_found(code),
            reply_markup=create_back_menu()
        )


async def callback_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    query = update.callback_query
    await query.answer()

    data = query.data

    # ĞĞ±Ñ€Ğ°Ğ±Ğ¾Ñ‚ĞºĞ° Ğ²Ñ‹Ğ±Ğ¾Ñ€Ğ° Ñ‚Ğ¸Ğ¿Ğ° ĞºĞ»Ğ¸ĞµĞ½Ñ‚Ğ°
    if data.startswith("type:"):
        return await receive_client_type(update, context)

    if data == "main_menu":
        menu_text = (
            "ğŸ  Ğ“Ğ›ĞĞ’ĞĞĞ• ĞœĞ•ĞĞ®\n"
            "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
            "Ğ’Ñ‹Ğ±ĞµÑ€Ğ¸Ñ‚Ğµ Ğ´ĞµĞ¹ÑÑ‚Ğ²Ğ¸Ğµ Ğ¸Ğ»Ğ¸ Ğ½Ğ°Ğ¿Ğ¸ÑˆĞ¸Ñ‚Ğµ\n"
            "Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ‚Ğ¾Ğ²Ğ°Ñ€Ğ° Ğ´Ğ»Ñ Ğ¿Ñ€Ğ¾Ğ²ĞµÑ€ĞºĞ¸\n"
            "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        )
        await query.edit_message_text(menu_text, reply_markup=create_main_menu())

    elif data == "new_search":
        search_text = (
            "ğŸ” ĞŸĞĞ˜Ğ¡Ğš Ğ¢ĞĞ’ĞĞ Ğ\n"
            "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
            "ĞĞ°Ğ¿Ğ¸ÑˆĞ¸Ñ‚Ğµ Ğ½Ğ°Ğ·Ğ²Ğ°Ğ½Ğ¸Ğµ Ñ‚Ğ¾Ğ²Ğ°Ñ€Ğ°\n"
            "Ğ¸Ğ»Ğ¸ ĞºĞ¾Ğ´ Ğ¢ĞĞ’Ğ­Ğ”:\n\n"
            "ğŸ’¡ ĞŸÑ€Ğ¸Ğ¼ĞµÑ€Ñ‹:\n"
            "   Ğ¾Ğ±ÑƒĞ²ÑŒ, Ğ¼Ğ¾Ğ»Ğ¾ĞºĞ¾, ÑˆĞ¸Ğ½Ñ‹, 6403\n"
            "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        )
        await query.edit_message_text(search_text, reply_markup=create_search_menu())

    elif data == "cat":
        text = "ğŸ“š ĞšĞĞ¢Ğ•Ğ“ĞĞ Ğ˜Ğ˜ ĞœĞĞ ĞšĞ˜Ğ ĞĞ’ĞšĞ˜\n"
        text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
        for i, (cat_name, cat_data) in enumerate(category_requirements.items(), 1):
            decree = cat_data.get('decree', {})
            text += f"{i}. {cat_name}\n   ğŸ“‹ â„– {decree.get('number', '?')}\n\n"
        text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        await query.edit_message_text(text, reply_markup=create_back_menu())

    elif data == "ai_consultant":
        ai_text = (
            "ğŸ¤– AI-ĞšĞĞĞ¡Ğ£Ğ›Ğ¬Ğ¢ĞĞĞ¢\n"
            "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
            "ğŸš€ Ğ¡ĞºĞ¾Ñ€Ğ¾!\n\n"
            "Ğ£Ğ¼Ğ½Ñ‹Ğ¹ Ğ¿Ğ¾Ğ¼Ğ¾Ñ‰Ğ½Ğ¸Ğº Ğ½Ğ° Ğ±Ğ°Ğ·Ğµ Ğ˜Ğ˜,\n"
            "ĞºĞ¾Ñ‚Ğ¾Ñ€Ñ‹Ğ¹ Ğ¾Ñ‚Ğ²ĞµÑ‚Ğ¸Ñ‚ Ğ½Ğ° Ğ»ÑĞ±Ñ‹Ğµ\n"
            "Ğ²Ğ¾Ğ¿Ñ€Ğ¾ÑÑ‹ Ğ¿Ğ¾ Ğ¼Ğ°Ñ€ĞºĞ¸Ñ€Ğ¾Ğ²ĞºĞµ:\n\n"
            "â€¢ Ğ¢Ñ€ĞµĞ±Ğ¾Ğ²Ğ°Ğ½Ğ¸Ñ Ğº ÑÑ‚Ğ¸ĞºĞµÑ‚ĞºĞ°Ğ¼\n"
            "â€¢ Ğ Ğ°Ğ±Ğ¾Ñ‚Ğ° Ñ Ğ§ĞµÑÑ‚Ğ½Ñ‹Ğ¼ Ğ·Ğ½Ğ°ĞºĞ¾Ğ¼\n"
            "â€¢ Ğ¨Ñ‚Ñ€Ğ°Ñ„Ñ‹ Ğ¸ Ğ¾Ñ‚Ğ²ĞµÑ‚ÑÑ‚Ğ²ĞµĞ½Ğ½Ğ¾ÑÑ‚ÑŒ\n"
            "â€¢ Ğ¡Ğ»Ğ¾Ğ¶Ğ½Ñ‹Ğµ ÑĞ»ÑƒÑ‡Ğ°Ğ¸ Ğ¸ Ğ¸ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ\n"
            "â€¢ Ğ˜Ğ½Ñ‚ĞµĞ³Ñ€Ğ°Ñ†Ğ¸Ñ Ñ 1Ğ¡ Ğ¸ ĞœĞ¾Ğ¹Ğ¡ĞºĞ»Ğ°Ğ´\n\n"
            "ğŸ“§ Ğ¥Ğ¾Ñ‚Ğ¸Ñ‚Ğµ ÑƒĞ·Ğ½Ğ°Ñ‚ÑŒ Ğ¿ĞµÑ€Ğ²Ñ‹Ğ¼Ğ¸?\n"
            "   Ğ¡Ğ»ĞµĞ´Ğ¸Ñ‚Ğµ Ğ·Ğ° Ğ½Ğ¾Ğ²Ğ¾ÑÑ‚ÑĞ¼Ğ¸!\n"
            "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
        )
        await query.edit_message_text(ai_text, reply_markup=create_back_menu())

    elif data.startswith("t:"):
        cat_id = data[2:]
        category = get_category_by_id(cat_id)
        text = format_timeline(category) if category else "âŒ ĞšĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ñ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°."
        await query.edit_message_text(text, reply_markup=create_back_menu())

    elif data.startswith("e:"):
        cat_id = data[2:]
        category = get_category_by_id(cat_id)

        if category:
            details = get_category_details(category)
            if details and details['data'].get('exceptions'):
                text = f"âš ï¸ Ğ˜Ğ¡ĞšĞ›Ğ®Ğ§Ğ•ĞĞ˜Ğ¯\n"
                text += "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n\n"
                text += f"ğŸ“¦ {details['category']}\n\n"
                for item in details['data']['exceptions']:
                    text += f"â€¢ {item}\n"
                text += "\nâ”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”\n"
                text += "ğŸŒ promarkirui.ru"
            else:
                text = "â„¹ï¸ Ğ˜ÑĞºĞ»ÑÑ‡ĞµĞ½Ğ¸Ñ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ñ‹ Ğ´Ğ»Ñ ÑÑ‚Ğ¾Ğ¹ ĞºĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ğ¸."
        else:
            text = "âŒ ĞšĞ°Ñ‚ĞµĞ³Ğ¾Ñ€Ğ¸Ñ Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½Ğ°."

        await query.edit_message_text(text, reply_markup=create_back_menu())


async def error_handler(update: Update, context: ContextTypes.DEFAULT_TYPE):
    logger.error(f"Error: {context.error}")


def main():
    load_data()

    token = os.getenv('TELEGRAM_BOT_TOKEN')
    if not token:
        logger.error("TELEGRAM_BOT_TOKEN Ğ½Ğµ Ğ½Ğ°Ğ¹Ğ´ĞµĞ½")
        return

    app = Application.builder().token(token).build()

    conv_handler = ConversationHandler(
        entry_points=[CommandHandler("start", start)],
        states={
            WAITING_PHONE: [
                MessageHandler(filters.CONTACT, receive_contact),
                MessageHandler(filters.TEXT & ~filters.COMMAND, handle_phone_text),
            ],
            WAITING_CLIENT_TYPE: [
                CallbackQueryHandler(receive_client_type, pattern="^type:"),
            ],
            WAITING_CUSTOM_TYPE: [
                MessageHandler(filters.TEXT & ~filters.COMMAND, receive_custom_type),
            ],
        },
        fallbacks=[CommandHandler("start", start)],
        per_message=False,
    )

    app.add_handler(conv_handler)
    app.add_handler(CommandHandler("help", help_command))
    app.add_handler(CommandHandler("menu", menu_command))
    app.add_handler(CommandHandler("categories", categories_command))
    app.add_handler(CallbackQueryHandler(callback_handler))
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, handle_message))
    app.add_error_handler(error_handler)

    logger.info("Ğ‘Ğ¾Ñ‚ Ğ·Ğ°Ğ¿ÑƒÑ‰ĞµĞ½...")
    app.run_polling(allowed_updates=Update.ALL_TYPES)


if __name__ == '__main__':
    main()
